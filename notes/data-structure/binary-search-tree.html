
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Binary Search Tree &#8212; Let&#39;s LeetCode in Python</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet">
  <link href="../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Algorithm" href="../algorithm/content.html" />
    <link rel="prev" title="Data Structure" href="content.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Let's LeetCode in Python</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../intro.html">
   Introduction
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Basics
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../basics/overview.html">
   Overview
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../basics/lectures.html">
   Lectures
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../basics/lecture1.html">
     Lecture 1: Introduction
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../basics/lecture2.html">
     Lecture 2: Data Structure and Dynamic Array
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../basics/lecture3.html">
     Lecture 3: Set and Sorting
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../basics/lecture4.html">
     Hashing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../basics/lecture5.html">
     Lecture 5: Linear Sorting
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../basics/lecture6.html">
     Lecture 6: Binary Trees - I
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../basics/lecture7.html">
     Lecture 7: Binary Trees - II
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../basics/lecture8.html">
     Lecture 8: Binary Heap
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../basics/lecture9.html">
     Lecture 9: Breadth-First Search
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../basics/lecture10.html">
     Lecture 10: Depth-First Search
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../basics/lecture11.html">
     Lecture 11: Weighted Shortest Path
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../basics/lecture12.html">
     Lecture 12: The Bellman-Ford Algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../basics/lecture13.html">
     Lecture 13: The Dijkstraâ€™s Algorithm
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Notes
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="content.html">
   Data Structure
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Binary Search Tree
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../algorithm/content.html">
   Algorithm
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../algorithm/bigO.html">
     Big-O Complexity
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../algorithm/recursive-algorithms.html">
     Recursion
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../algorithm/sorting-algorithm.html">
     Sort
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../algorithm/search-algorithm.html">
     Search
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../algorithm/graph-algorithm.html">
     Graph algorithm
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  LeetCode
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../leetcode/solutions.html">
   Solutions
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../leetcode/0001-two-sum.html">
     0001. Two Sum
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../leetcode/0003-longest-substring.html">
     0003. Longest Substring without Repeating Characters
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../leetcode/0004-median-two-sorted-array.html">
     0004. Median of Two Sorted Arrays
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../leetcode/0005-longest-palindromic-string.html">
     0005. Longest Palindromic String
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../leetcode/0015-three-sum.html">
     0015. Three Sum
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../leetcode/0016-three-sum-closest.html">
     0016. Three Sum Closest
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../leetcode/0018-four-sum.html">
     0018. Four Sum
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../leetcode/0022-generate-parentheses.html">
     0022 Generate Parentheses
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../leetcode/0092-reversed-linked-list-II.html">
     0092. Reversed Linked List ii
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../leetcode/0167-two-sum-ii.html">
     0167. Two Sum II
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../leetcode/0189-rotate-array.html">
     0189. Rotate Array
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../leetcode/0200-number-of-islands.html">
     0200. Number of islands
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../leetcode/0206-reversed-linked-list.html">
     0206. Reversed Linked List
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../leetcode/0463-island-perimeter.html">
     0463. Island Perimeter
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../leetcode/0695-max-area-of-island.html">
     0695. Max Area of Island
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../leetcode/0704-binary-search.html">
     0704. Binary Search
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../leetcode/0733-flood-fill.html">
     0733. Flood Fill
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Convex Optimization
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../convex-optimization/newton-method.html">
   Newton Iterative Method
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../convex-optimization/interior-point-method.html">
   Interior-point Method
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/notes/data-structure/binary-search-tree.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/YangyangFu/letsleetcode-python"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/YangyangFu/letsleetcode-python/issues/new?title=Issue%20on%20page%20%2Fnotes/data-structure/binary-search-tree.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/YangyangFu/letsleetcode-python/master?urlpath=tree/letsleetcode/notes/data-structure/binary-search-tree.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#build">
   Build
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#method-1">
     Method 1
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#method-2">
     Method 2
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#method-3">
     Method 3
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#method-4">
     Method 4
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#traverse">
   Traverse
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#preorder-traversal">
     Preorder Traversal
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#inorder">
     Inorder
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#postorder">
     Postorder
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#level-order-traversal">
     Level Order Traversal
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#insertion">
   Insertion
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#deletion">
   Deletion
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#search">
   Search
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Binary Search Tree</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#build">
   Build
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#method-1">
     Method 1
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#method-2">
     Method 2
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#method-3">
     Method 3
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#method-4">
     Method 4
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#traverse">
   Traverse
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#preorder-traversal">
     Preorder Traversal
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#inorder">
     Inorder
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#postorder">
     Postorder
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#level-order-traversal">
     Level Order Traversal
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#insertion">
   Insertion
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#deletion">
   Deletion
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#search">
   Search
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="binary-search-tree">
<h1>Binary Search Tree<a class="headerlink" href="#binary-search-tree" title="Permalink to this headline">Â¶</a></h1>
<p>Binary Search Tree (BST) is a node-based binary tree data structure which has the following properties:</p>
<ul class="simple">
<li><p>The left subtree of a node contains only nodes with <code class="docutils literal notranslate"><span class="pre">keys</span> <span class="pre">less</span> <span class="pre">than</span> <span class="pre">the</span> <span class="pre">nodeâ€™s</span> <span class="pre">key</span></code>.</p></li>
<li><p>The right subtree of a node contains only nodes with <code class="docutils literal notranslate"><span class="pre">keys</span> <span class="pre">greater</span> <span class="pre">than</span> <span class="pre">the</span> <span class="pre">nodeâ€™s</span> <span class="pre">key</span></code>.</p></li>
<li><p>This means <code class="docutils literal notranslate"><span class="pre">everything</span> <span class="pre">to</span> <span class="pre">the</span> <span class="pre">left</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">root</span> <span class="pre">is</span> <span class="pre">less</span> <span class="pre">than</span> <span class="pre">the</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">root</span> <span class="pre">and</span> <span class="pre">everything</span> <span class="pre">to</span> <span class="pre">the</span> <span class="pre">right</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">root</span> <span class="pre">is</span> <span class="pre">greater</span> <span class="pre">than</span> <span class="pre">the</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">root</span></code>. Due to this performing, a binary search is very easy.</p></li>
<li><p>The left and right subtree each must also be a binary search tree.</p></li>
<li><p>There must be no duplicate nodes (BST may have duplicate values with different handling approaches)</p></li>
</ul>
<p><strong>Terminology</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">traversal</span> <span class="pre">order</span></code>: the order of the nodes generated from a given traversal direction.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">preorder</span> <span class="pre">traversal</span></code>: repeatly traverse the node first, then the left and lastly the right.</p></li>
</ul>
<p><strong>Key Properties</strong></p>
<ul class="simple">
<li><p>Keep track of the range of node value. -&gt; can be used to check if a tree is a valid BST or construct a BST from given preorder traversal order.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">def</span> <span class="nf">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span> <span class="nf">printTree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;preorder&#39;</span><span class="p">):</span>
    <span class="n">traversal</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;preorder&quot;</span><span class="p">:</span>
        <span class="k">pass</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="build">
<h2>Build<a class="headerlink" href="#build" title="Permalink to this headline">Â¶</a></h2>
<p>How to build a BST from given preorder traversal? For example if the given preorder traversal is [10,5,1,7,40,50], then the BST has the following format:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        10
        / \
       5   40
      / \    \
     1   7   50
</pre></div>
</div>
<p><strong>Important</strong></p>
<ul class="simple">
<li><p>In <code class="docutils literal notranslate"><span class="pre">preorder</span></code> traversal, the root node always comes first.</p></li>
<li><p>The key is to find its left subtree and right subtree from a given root using the above principle.</p></li>
<li><p>Together with <code class="docutils literal notranslate"><span class="pre">inorder</span></code>, where left subtree always comes first, it is easy to reconstruct a binary tree.</p></li>
</ul>
<p><strong>Leetcode</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/">1008</a></p></li>
</ul>
<div class="section" id="method-1">
<h3>Method 1<a class="headerlink" href="#method-1" title="Permalink to this headline">Â¶</a></h3>
<ul class="simple">
<li><p>The first element of the preorder traversal <code class="docutils literal notranslate"><span class="pre">A</span></code> is always root.</p></li>
<li><p>Then we find the first element that is greater than the root, and get its index <code class="docutils literal notranslate"><span class="pre">i</span></code>. In 0-index language, any values between <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">i</span></code> shall be the left subtree, and values between <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">-1</span></code> shall be the right subtree.</p></li>
<li><p>Recursively cconstruct the left subtree using <code class="docutils literal notranslate"><span class="pre">A[1:i]</span></code> and right subtree using <code class="docutils literal notranslate"><span class="pre">A[i:]</span></code>.</p></li>
</ul>
<p><strong>Complexity</strong></p>
<ul class="simple">
<li><p>time: <span class="math notranslate nohighlight">\(O(n^2)\)</span></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_preorder</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="c1"># return None if empty</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">A</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># get root</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">val</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="c1"># get left subtree and right subtree</span>
    <span class="c1"># using the first element of the right subtree</span>
    <span class="c1"># or we can use inorder traversal here by sorting the preorder traversal</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="c1"># recurse</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">build_preorder</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">build_preorder</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
    
    <span class="c1"># combine </span>
    <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span> 
    <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span> 

    <span class="k">return</span> <span class="n">root</span>
    
<span class="c1"># test</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">build_preorder</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">build_preorder</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">build_preorder</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[10, 5, 1, 7, 40, 50]
[]
[1]
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="method-2">
<h3>Method 2<a class="headerlink" href="#method-2" title="Permalink to this headline">Â¶</a></h3>
<p>Traverse each element in the preorder traversal, and compare its value with the root value</p>
<ul class="simple">
<li><p>if the node value is less than the root value, change root to its left</p></li>
<li><p>if the node value is greater than the root value, change root to its right</p></li>
<li><p>recurse until the node is inserted correctly</p></li>
</ul>
<p><strong>Complexity</strong></p>
<ul class="simple">
<li><p>time: <span class="math notranslate nohighlight">\(O(n^2)\)</span></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">buildBST</span><span class="p">(</span><span class="n">preorder</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">A</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span> 
    
    <span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">preorder</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">root</span>
    
    <span class="c1"># insert</span>
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="c1"># base case</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span>
        
        <span class="c1"># insert to left tree or right tree</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">root</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    
    <span class="k">return</span> <span class="n">root</span>

<span class="c1"># test</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[10, 5, 1, 7, 40, 50]
[]
[1]
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="method-3">
<h3>Method 3<a class="headerlink" href="#method-3" title="Permalink to this headline">Â¶</a></h3>
<p>The information of the binary tree can be saved using preorder traversal and inorder traversal.</p>
<p>The key idea here is:</p>
<ul class="simple">
<li><p>preorder traversal preserves the node order in [root, left, right]</p></li>
<li><p>inorder traversal preserves the node order in [left, root, right]. For BST, the inorder traversal is sorted increasingly.</p>
<ul>
<li><p>we can get the inroder traversal of BST easily from sorting the preorder traversal.</p></li>
<li><p>The first element in the preorder traversal is always the root, and the left slice of the inorder traversal to the root is the whole left subtree.</p></li>
<li><p>Therefore, we just need to know the index of the root in the inorder traversal.</p></li>
</ul>
</li>
</ul>
<p><strong>Complexity</strong></p>
<ul class="simple">
<li><p>time: <span class="math notranslate nohighlight">\(O(n^2log(n))\)</span></p></li>
<li><p>space: <span class="math notranslate nohighlight">\(O(n)\)</span>. Extra space for storing inorder traversal and recursive call stack, whose worst scenario is <span class="math notranslate nohighlight">\(O(n)\)</span> when the tree is left-skewed.</p></li>
</ul>
<p><strong>This could be improved to <span class="math notranslate nohighlight">\(O(n)\)</span> time</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">buildBST</span><span class="p">(</span><span class="n">preorder</span><span class="p">):</span>
    <span class="c1"># base case</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">preorder</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    
    <span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># get inorder traversal of a BST</span>
    <span class="n">inorder</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">preorder</span><span class="p">)</span>

    <span class="c1"># find root index in inorder traversal</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">inorder</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="c1"># build left</span>
    <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">inorder</span><span class="p">[:</span><span class="n">ind</span><span class="p">])</span>
    <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">inorder</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">root</span>

<span class="c1"># test</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[10, 1, 5, 7, 40, 50]
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="method-4">
<h3>Method 4<a class="headerlink" href="#method-4" title="Permalink to this headline">Â¶</a></h3>
<p>See https://www.youtube.com/watch?v=UmJT3j26t1I.</p>
<p>BST node has a property that determines the range of its subtree.
The key idea here is use the upper bounds of each explored node to decide where a specific node should be inserted:</p>
<ul class="simple">
<li><p>initialize the upper bound of the root as <code class="docutils literal notranslate"><span class="pre">INF</span></code></p></li>
<li><p>for each node, recursively</p>
<ul>
<li><p>build the left subtree using upper bound <code class="docutils literal notranslate"><span class="pre">node.val</span></code></p></li>
<li><p>build the right subtree using upper bound the current nodeâ€™s parent upper bound</p></li>
</ul>
</li>
</ul>
<p><strong>Complexity</strong></p>
<ul class="simple">
<li><p>time: O(n). For each node, we at most visit 3 times, thus the worst scenario is <span class="math notranslate nohighlight">\(O(3n)\)</span>, which is <span class="math notranslate nohighlight">\(O(n)\)</span></p></li>
<li><p>space: O(1). This recursive algorithm uses stack space.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># The recusion is so beatiful here. Try to understand</span>
<span class="c1"># The key point here is: </span>
<span class="c1"># 1. A is globally changed by each recursion.</span>
<span class="c1"># 2. The recusion always build left brach first. Until no left node is possible, it will build the right branch from the bottom of left subtree to the right subtree of the root.</span>
<span class="k">def</span> <span class="nf">buildBST</span><span class="p">(</span><span class="n">preorder</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">A</span> <span class="ow">or</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ub</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>
        <span class="c1">#print(A)</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;A for left: </span><span class="si">{</span><span class="n">A</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;A for right: </span><span class="si">{</span><span class="n">A</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">root</span>

    <span class="k">return</span> <span class="n">build</span><span class="p">(</span><span class="n">preorder</span><span class="p">)</span> 

<span class="c1"># test</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

<span class="c1">#A = []</span>
<span class="c1">#root = buildBST(A)</span>
<span class="c1">#print(traverse_preorder(root))</span>

<span class="c1">#A = [1]</span>
<span class="c1">#root = buildBST(A)</span>
<span class="c1">#print(traverse_preorder(root))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>A for left: [5, 1, 7, 40, 50]
A for left: [1, 7, 40, 50]
A for left: [7, 40, 50]
A for right: [7, 40, 50]
A for right: [7, 40, 50]
A for left: [40, 50]
A for right: [40, 50]
A for right: [40, 50]
A for left: [50]
A for right: [50]
A for left: []
A for right: []
[10, 5, 1, 7, 40, 50]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># A wrong implementation:</span>
<span class="c1"># the index i is not global, which results the same node will be attached to both left and right if possible.</span>
<span class="k">def</span> <span class="nf">buildBST</span><span class="p">(</span><span class="n">preorder</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="ow">or</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ub</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">root</span>

    <span class="k">return</span> <span class="n">build</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> 

<span class="c1"># The following implementation fixes the above code</span>
<span class="k">def</span> <span class="nf">buildBST</span><span class="p">(</span><span class="n">preorder</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">i</span> 
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)):</span>
        <span class="k">global</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="ow">or</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ub</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">root</span>

    <span class="k">return</span> <span class="n">build</span><span class="p">(</span><span class="n">preorder</span><span class="p">)</span> 

<span class="c1"># test</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[10, 5, 1, 7, 40, 50]
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="traverse">
<h2>Traverse<a class="headerlink" href="#traverse" title="Permalink to this headline">Â¶</a></h2>
<p>Traverse the BST node by node.</p>
<div class="section" id="preorder-traversal">
<h3>Preorder Traversal<a class="headerlink" href="#preorder-traversal" title="Permalink to this headline">Â¶</a></h3>
<p>Preorder traversal is used to create a copy of the tree. Preorder traversal is also used to get prefix expressions on an expression tree.</p>
<ul class="simple">
<li><p>visit the root</p></li>
<li><p>traverse the left subtree</p></li>
<li><p>traverse the right subtree</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="c1"># base case</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># store node </span>
    <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">]</span>
    <span class="c1"># traverse the left subtree and right subtree</span>
    <span class="n">order</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">))</span>
    <span class="n">order</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">))</span>
    
    <span class="c1"># return</span>
    <span class="k">return</span> <span class="n">order</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[10, 5, 1, 7, 40, 50]
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="inorder">
<h3>Inorder<a class="headerlink" href="#inorder" title="Permalink to this headline">Â¶</a></h3>
<p>In the case of BST, Inorder traversal gives nodes in non-decreasing order. To get nodes of BST in non-increasing order, a variation of Inorder traversal where Inorder traversal is reversed can be used.</p>
<ul class="simple">
<li><p>traverse the left subtree</p></li>
<li><p>visit the root</p></li>
<li><p>traverse the rigth subtree</p></li>
</ul>
<p><strong>Recursive Implementation</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## A recursive implementation</span>
<span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="c1"># base case</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># traverse left subtree</span>
    <span class="n">order</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">))</span>
    <span class="n">order</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">])</span>
    <span class="n">order</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">order</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 5, 7, 10, 40, 50]
</pre></div>
</div>
</div>
</div>
<p><strong>Iterative Implementation Using Stack</strong></p>
<ol>
<li><p>Create an empty stack S.</p></li>
<li><p>Initialize current node as root</p></li>
<li><p>Push the current node to S and set <code class="docutils literal notranslate"><span class="pre">current</span> <span class="pre">=</span> <span class="pre">current.left</span></code> until current is NULL</p></li>
<li><p>If current is NULL and stack is not empty then</p>
<ul class="simple">
<li><p>Pop the top item from stack.</p></li>
<li><p>Print the popped item, set <code class="docutils literal notranslate"><span class="pre">current</span> <span class="pre">=</span> <span class="pre">popped_item.right</span></code></p></li>
<li><p>Go to step 3.</p></li>
</ul>
</li>
<li><p>If current is NULL and stack is empty then we are done</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">============================================================</span>
Let us consider the below tree <span class="k">for</span> example  


            <span class="m">1</span>
          /   <span class="se">\</span>
        <span class="m">2</span>      <span class="m">3</span>
       /  <span class="se">\</span>
     <span class="m">4</span>     <span class="m">5</span>

Step <span class="m">1</span> Creates an empty stack: <span class="nv">S</span> <span class="o">=</span> NULL

Step <span class="m">2</span> sets current as address of root: current -&gt; <span class="m">1</span>

Step <span class="m">3</span> Pushes the current node and <span class="nb">set</span> <span class="nv">current</span> <span class="o">=</span> current-&gt;left 
     <span class="k">until</span> current is NULL
     current -&gt; <span class="m">1</span>
     push <span class="m">1</span>: Stack S -&gt; <span class="m">1</span>
     current -&gt; <span class="m">2</span>
     push <span class="m">2</span>: Stack S -&gt; <span class="m">2</span>, <span class="m">1</span>
     current -&gt; <span class="m">4</span>
     push <span class="m">4</span>: Stack S -&gt; <span class="m">4</span>, <span class="m">2</span>, <span class="m">1</span>
     <span class="nv">current</span> <span class="o">=</span> NULL

Step <span class="m">4</span> pops from S
     a<span class="o">)</span> Pop <span class="m">4</span>: Stack S -&gt; <span class="m">2</span>, <span class="m">1</span>
     b<span class="o">)</span> print <span class="s2">&quot;4&quot;</span>
     c<span class="o">)</span> <span class="nv">current</span> <span class="o">=</span> NULL /*right of <span class="m">4</span> */ and go to step <span class="m">3</span>
Since current is NULL step <span class="m">3</span> doesn<span class="s1">&#39;t do anything. </span>

<span class="s1">Step 4 pops again.</span>
<span class="s1">     a) Pop 2: Stack S -&gt; 1</span>
<span class="s1">     b) print &quot;2&quot;</span>
<span class="s1">     c) current -&gt; 5/*right of 2 */ and go to step 3</span>

<span class="s1">Step 3 pushes 5 to stack and makes current NULL</span>
<span class="s1">     Stack S -&gt; 5, 1</span>
<span class="s1">     current = NULL</span>

<span class="s1">Step 4 pops from S</span>
<span class="s1">     a) Pop 5: Stack S -&gt; 1</span>
<span class="s1">     b) print &quot;5&quot;</span>
<span class="s1">     c) current = NULL /*right of 5 */ and go to step 3</span>
<span class="s1">Since current is NULL step 3 doesn&#39;</span>t <span class="k">do</span> anything

Step <span class="m">4</span> pops again.
     a<span class="o">)</span> Pop <span class="m">1</span>: Stack S -&gt; NULL
     b<span class="o">)</span> print <span class="s2">&quot;1&quot;</span>
     c<span class="o">)</span> current -&gt; <span class="m">3</span> /*right of <span class="m">1</span> */  

Step <span class="m">3</span> pushes <span class="m">3</span> to stack and makes current NULL
     Stack S -&gt; <span class="m">3</span>
     <span class="nv">current</span> <span class="o">=</span> NULL

Step <span class="m">4</span> pops from S
     a<span class="o">)</span> Pop <span class="m">3</span>: Stack S -&gt; NULL
     b<span class="o">)</span> print <span class="s2">&quot;3&quot;</span>
     c<span class="o">)</span> <span class="nv">current</span> <span class="o">=</span> NULL /*right of <span class="m">3</span> */  

Traversal is <span class="k">done</span> now as stack S is empty and current is NULL.
</pre></div>
</div>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## A iterative implementation: use a stack to store </span>
<span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="c1"># if use stack=[root]</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">root</span>
    <span class="c1"># Note len([None]=1)</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="c1"># pop if current is none and stack is not empty</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">curr</span><span class="p">:</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="c1"># get the order</span>
            <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="c1"># update current node</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">right</span>
        
        <span class="c1"># push all left nodes and then right node</span>
        <span class="k">while</span> <span class="n">curr</span><span class="p">:</span>
            <span class="c1"># avoid storing root twice</span>
            <span class="k">if</span> <span class="n">curr</span><span class="o">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">left</span>

    <span class="k">return</span> <span class="n">order</span>

<span class="c1"># Test</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">40</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 5, 7, 10, 40]
</pre></div>
</div>
</div>
</div>
<p><strong>Iterative Implementation without Stack</strong></p>
<p>This method is known as Morris Traversal.
See <a class="reference external" href="https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/?ref=lbp">here</a>.</p>
</div>
<div class="section" id="postorder">
<h3>Postorder<a class="headerlink" href="#postorder" title="Permalink to this headline">Â¶</a></h3>
<p>Postorder traversal is used to delete the tree. Please see the question for the deletion of a tree for details. Postorder traversal is also useful to get the postfix expression of an expression tree</p>
<ul class="simple">
<li><p>traverse the left subtree</p></li>
<li><p>traverse the right subtree</p></li>
<li><p>visit the root</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">postorder</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="c1"># base </span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># traverse </span>
    <span class="n">order</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">postorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">))</span>
    <span class="n">order</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">postorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">))</span>
    <span class="n">order</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">])</span>

    <span class="c1"># return</span>
    <span class="k">return</span> <span class="n">order</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">postorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 5, 7, 10, 40, 50]
[1, 7, 5, 50, 40, 10]
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="level-order-traversal">
<h3>Level Order Traversal<a class="headerlink" href="#level-order-traversal" title="Permalink to this headline">Â¶</a></h3>
<p>Traverse the tree level by level</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">levelorder</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>

    <span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="c1"># dequeue</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># do something</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
            <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;null&#39;</span><span class="p">)</span>
        <span class="c1"># enqueue</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">and</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">):</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">order</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">levelorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 5, 7, 10, 40, 50]
[10, 5, 40, 1, 7, &#39;null&#39;, 50]
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="insertion">
<h2>Insertion<a class="headerlink" href="#insertion" title="Permalink to this headline">Â¶</a></h2>
<p>A new key is always inserted at the leaf. We start searching for a key from the root until we hit a leaf node. Once a leaf node is found, the new node is added as a child of the leaf node.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>        Insert 3 to the following BST will lead to:

             10                                              10
            /  \                     insert 3               /  \
           5   40                    -------&gt;              5   40              
          / \    \                                        / \    \
         1  7    50                                      1   7   50
                                                          \
                                                           3
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># A recursion Implementation</span>
<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="c1"># base case</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span>
    
    <span class="c1"># insert recursively assuming no duplicates</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">:</span>
        <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">root</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>    
<span class="nb">print</span><span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 3, 5, 7, 10, 40, 50]
[10, 5, 1, 3, 7, 40, 50]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># An iterative implementation</span>
<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span> 
    <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span> 

    <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">cur</span>
        <span class="c1"># go left</span>
        <span class="k">if</span> <span class="n">cur</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">:</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">left</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># go right</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">right</span>
    
    <span class="c1"># specify connections</span>
    <span class="k">if</span> <span class="n">prev</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">:</span>
        <span class="n">prev</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">node</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="n">prev</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span>
    
    <span class="k">return</span> <span class="n">root</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>    
<span class="nb">print</span><span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 3, 5, 7, 10, 40, 50]
[10, 5, 1, 3, 7, 40, 50]
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="deletion">
<h2>Deletion<a class="headerlink" href="#deletion" title="Permalink to this headline">Â¶</a></h2>
<p>When we delete a node, three possibilities arise.</p>
<ol class="simple">
<li><p>Node to be deleted is the leaf: Simply remove from the tree.</p></li>
</ol>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>              50                            50
           /     \         delete(20)      /   \
          30      70       ---------&gt;    30     70 
         /  \    /  \                     \    /  \ 
       20   40  60   80                   40  60   80
</pre></div>
</div>
<ol class="simple">
<li><p>Node to be deleted has only one child: Copy the child to the node and delete the child</p></li>
</ol>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>              50                            50
           /     \         delete(30)      /   \
          30      70       ---------&gt;    40     70 
            \    /  \                          /  \ 
            40  60   80                       60   80
</pre></div>
</div>
<ol class="simple">
<li><p>Node to be deleted has two children: Find <code class="docutils literal notranslate"><span class="pre">inorder</span> <span class="pre">successor</span></code> of the node. Copy contents of the inorder successor to the node and delete the inorder successor. Note that <code class="docutils literal notranslate"><span class="pre">inorder</span> <span class="pre">predecessor</span></code> can also be used.</p></li>
</ol>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>              50                            60
           /     \         delete(50)      /   \
          40      70       ---------&gt;    40    70 
                 /  \                            \ 
                60   80                           80
</pre></div>
</div>
<p>The important thing to note is, inorder successor is needed only when the right child is not empty. In this particular case, inorder successor can be obtained by finding the minimum value in the right child of the node.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">successor</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;find the inorder successor for a given node</span>
<span class="sd">            - if root has no right child, return None</span>
<span class="sd">            - else return the leftmost node in the right subtree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span> 
        
        <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span>
        <span class="k">while</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span>

        <span class="k">return</span> <span class="n">node</span>

    <span class="c1"># base case</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">root</span> 
    
    <span class="c1"># if key is smaller than the root&#39;s key then it lies in the left subtree</span>
    <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
        <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="c1"># key is the same as the root key</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># root is a leaf</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># root has only one child - left </span>
        <span class="k">elif</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
            <span class="n">root</span> <span class="o">=</span> <span class="kc">None</span> 
            <span class="k">return</span> <span class="n">temp</span>
        <span class="c1"># root has only one child - right</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span>
            <span class="n">root</span> <span class="o">=</span> <span class="kc">None</span> 
            <span class="k">return</span> <span class="n">temp</span> 
        
        <span class="c1"># root has two children</span>
        <span class="n">succ</span> <span class="o">=</span> <span class="n">successor</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

        <span class="c1"># copy the content</span>
        <span class="c1">#right = root.right # need reverse the right subtree before deletion</span>
        <span class="c1">#left = root.left</span>
        <span class="n">root</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">succ</span><span class="o">.</span><span class="n">val</span>

        <span class="c1"># delete the inorder successor</span>
        <span class="c1">#root.left = left</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">succ</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">root</span>

<span class="c1"># test</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">70</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="mi">80</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  
<span class="n">root</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">70</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="mi">80</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  
<span class="n">root</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">70</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="mi">80</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  
<span class="n">root</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[50, 30, 40, 70, 60, 80]
[50, 40, 70, 60, 80]
[60, 40, 70, 80]
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="search">
<h2>Search<a class="headerlink" href="#search" title="Permalink to this headline">Â¶</a></h2>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./notes/data-structure"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="content.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Data Structure</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="../algorithm/content.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Algorithm</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Yangyang Fu<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>