

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Chapter 4. Binary Search Tree &#8212; Let&#39;s LeetCode in Python</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=ac02cc09edc035673794" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=ac02cc09edc035673794" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794" />
  <script src="../../_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=ac02cc09edc035673794"></script>

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notes/data-structure/4-binary-search-tree';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Cahpter 5. Binary Tree" href="5-binary-tree.html" />
    <link rel="prev" title="Chapter 3. Stack" href="3-stack-and-queue.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../../_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Introduction
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Basics</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../basics/lectures.html">Lectures</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../basics/lectures/lecture01.html">Lecture 1: Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../basics/lectures/lecture02.html">Lecture 2: Data Structure and Dynamic Array</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../basics/lectures/lecture03.html">Lecture 3: Set and Sorting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../basics/lectures/lecture04.html">Hashing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../basics/lectures/lecture05.html">Lecture 5: Linear Sorting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../basics/lectures/lecture06.html">Lecture 6: Binary Trees - I</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../basics/lectures/lecture07.html">Lecture 7: Binary Trees - II</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../basics/lectures/lecture08.html">Lecture 8: Binary Heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../basics/lectures/lecture09.html">Lecture 9: Breadth-First Search</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../basics/lectures/lecture10.html">Lecture 10: Depth-First Search</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../basics/lectures/lecture11.html">Lecture 11: Weighted Shortest Path</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../basics/lectures/lecture12.html">Lecture 12: The Bellman-Ford Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../basics/lectures/lecture13.html">Lecture 13: The Dijkstra’s Algorithm</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../basics/overview.html">Overview</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Convex-optimization</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../convex-optimization/interior-point-method.html">Interior-point Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../convex-optimization/newton-method.html">Newton Iterative Method</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Leetcode</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../leetcode/solutions.html">Solutions</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0001-two-sum.html">0001. Two Sum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0003-longest-substring.html">0003. Longest Substring without Repeating Characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0004-median-two-sorted-array.html">0004. Median of Two Sorted Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0005-longest-palindromic-string.html">0005. Longest Palindromic String</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0015-three-sum.html">0015. Three Sum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0016-three-sum-closest.html">0016. Three Sum Closest</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0018-four-sum.html">0018. Four Sum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0021-merge-two-sorted-lists.html">0021 Merge Two Sorted Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0022-generate-parentheses.html">0022 Generate Parentheses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0023-merge-k-sorted-list.html">0023 Merge k Sorted Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0026-remove-duplicates.html">0026 Remove Duplicates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0027-remove-element.html">0027 Remove Element</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0048-rotate-image.html">0048 Rotate Image</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0054-spiral-matrix.html">0054 Spiral Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0059-spiral-matrix-II.html">0059 Spiral Matrix II</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0076-minimum-window-substring.html">0076 Minimum Window Substring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0083-remove-duplicates-linkedlist.html">0083 Remove Duplicates From Sorted List</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0086-partition-list.html">0086 Partition List</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0092-reversed-linked-list-II.html">0092. Reversed Linked List ii</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0115-distinct-subsequences.html">0115 Distinct Subsequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0160-intersection-of-two-linked-lists.html">0160 Intersection of Two Linked List</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0167-two-sum-ii.html">0167. Two Sum II</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0189-rotate-array.html">0189. Rotate Array</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0200-number-of-islands.html">0200. Number of islands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0206-reversed-linked-list.html">0206. Reversed Linked List</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0207-course-schedule.html">0207 Course Schedule</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0226-invert-binary-tree.html">0226. Invert Binary Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0236-lowest-common-ancestor.html">0236 Lowest Common Ancestor of a Binary Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0303-range-sum-query.html">0303 Range Sum Query</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0304-range-sum-query-2D.html">0304 Range Sum Query - 2D</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0323-number-of-connected-component.html">0323 Number of Connected Component in an Undirected Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0344-reverse-string.html">0344. Reverse String</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0370-range-addition.html">0370 Range Addition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0438-all-anagrams.html">0438 Find All Anagrams in a String</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0463-island-perimeter.html">0463. Island Perimeter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0494-target-sum.html">0494 Target Sum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0567-permutation-in-string.html">0567 Minimum Window Substring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0652-find-duplicate-subtrees.html">0652 Find Duplicate Subtrees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0695-max-area-of-island.html">0695. Max Area of Island</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0704-binary-search.html">0704. Binary Search</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0712-minimum-ascii-delete-sum.html">0712 Minimum ASCII Delete Sum for Two Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0733-flood-fill.html">0733. Flood Fill</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0743-network-delay-time.html">0733. Network Delay Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0797-all-paths-source-target.html">0797 All Paths From Source to Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/0886-possible-bipartition.html">0886 Possible Bipartition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/1109-flight-booking.html">1109 Flight Booking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/1514-path-with-maximum-prob.html">1514 Path With Maximum Probability</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/1584-min-cost-connect-all-points.html">1584 Min Cost to Connect All Points</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/1631-path-with-minimum-effort.html">1631 Path With Minimum Effort</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../leetcode/solutions/1976-number-ways-arrive-destination.html">1976 Number of Ways to Arrive at Destination</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Notes</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../algorithm.html">Algorithm</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../algorithm/backtracking-algorithm.html">Backtracking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algorithm/bigO.html">Big-O Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algorithm/graph-algorithm.html">Graph algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algorithm/recursive-algorithms.html">Recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algorithm/search-algorithm.html">Search</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algorithm/sorting-algorithm.html">Sort</a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="../data-structure.html">Data Structure</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1-array.html">Chapter 1. Array and String</a></li>
<li class="toctree-l2"><a class="reference internal" href="11-dynamic-programming-III.html">Chapter 11. Dynamic Programming III</a></li>
<li class="toctree-l2"><a class="reference internal" href="2-linked-list.html">Chapter 2. Singely Linked List</a></li>
<li class="toctree-l2"><a class="reference internal" href="3-stack-and-queue.html">Chapter 3. Stack</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Chapter 4. Binary Search Tree</a></li>


<li class="toctree-l2"><a class="reference internal" href="5-binary-tree.html">Cahpter 5. Binary Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="6-binary-search-tree-II.html">Chapter 6. Binary Search Tree II</a></li>
<li class="toctree-l2"><a class="reference internal" href="7-heap.html">Chapter 7: Binary Heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="8-graph.html">Chapter 8. Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="9-dynamic-programming-I.html">Chapter 9. Dynamic Programming I</a></li>
</ul>
</li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/YangyangFu/letsleetcode-python" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/YangyangFu/letsleetcode-python/issues/new?title=Issue%20on%20page%20%2Fnotes/data-structure/4-binary-search-tree.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/notes/data-structure/4-binary-search-tree.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Chapter 4. Binary Search Tree</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Chapter 4. Binary Search Tree</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#build">Build</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-preorder">From Preorder</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#method-1">Method 1</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#method-2">Method 2</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#method-3">Method 3</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#method-4">Method 4</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#build-all-bst-from-inorder-traversal">Build All BST from Inorder Traversal</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#traverse">Traverse</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#preorder-traversal">Preorder Traversal</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#inorder">Inorder</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#postorder">Postorder</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#level-order-traversal">Level Order Traversal</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#serialization-and-deserialization">Serialization and Deserialization</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#serialization-is-a-way-to-convert-a-binary-tree-to-a-standard-format-which-then-can-be-used-by-external-tools">Serialization is a way to convert a binary tree to a standard format, which then can be used by external tools.</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#insertion">Insertion</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#deletion">Deletion</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#search">Search</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#search-an-element">Search an element</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#minimum-and-maximum">Minimum and Maximum</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#successor-and-predecessor">Successor and Predecessor</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#applications">Applications</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#binary-tree-to-bst">Binary Tree to BST</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#analysis">Analysis</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tree-map">Tree Map</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Analysis</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#valid-bst">Valid BST</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#avl-tree">AVL Tree</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">Insertion</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#red-black-tree">Red-Black Tree</a></li>
</ul>

            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="chapter-4-binary-search-tree">
<h1>Chapter 4. Binary Search Tree<a class="headerlink" href="#chapter-4-binary-search-tree" title="Permalink to this heading">#</a></h1>
<p>Binary Search Tree (BST) is a node-based binary tree data structure which has the following properties:</p>
<ul class="simple">
<li><p>The left subtree of a node contains only nodes with <code class="docutils literal notranslate"><span class="pre">keys</span> <span class="pre">less</span> <span class="pre">than</span> <span class="pre">the</span> <span class="pre">node’s</span> <span class="pre">key</span></code>.</p></li>
<li><p>The right subtree of a node contains only nodes with <code class="docutils literal notranslate"><span class="pre">keys</span> <span class="pre">greater</span> <span class="pre">than</span> <span class="pre">the</span> <span class="pre">node’s</span> <span class="pre">key</span></code>.</p></li>
<li><p>This means <code class="docutils literal notranslate"><span class="pre">everything</span> <span class="pre">to</span> <span class="pre">the</span> <span class="pre">left</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">root</span> <span class="pre">is</span> <span class="pre">less</span> <span class="pre">than</span> <span class="pre">the</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">root</span> <span class="pre">and</span> <span class="pre">everything</span> <span class="pre">to</span> <span class="pre">the</span> <span class="pre">right</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">root</span> <span class="pre">is</span> <span class="pre">greater</span> <span class="pre">than</span> <span class="pre">the</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">root</span></code>. Due to this performing, a binary search is very easy.</p></li>
<li><p>The left and right subtree each must also be a binary search tree.</p></li>
<li><p>There must be no duplicate nodes (BST may have duplicate values with different handling approaches)</p></li>
</ul>
<p><strong>Terminology</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">traversal</span> <span class="pre">order</span></code>: the order of the nodes generated from a given traversal direction.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">preorder</span> <span class="pre">traversal</span></code>: repeatly traverse the node first, then the left and lastly the right.</p></li>
</ul>
<p><strong>Key Properties</strong></p>
<ul class="simple">
<li><p>Keep track of the range of node value. -&gt; can be used to check if a tree is a valid BST or construct a BST from given preorder traversal order.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">def</span> <span class="nf">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span> <span class="nf">printTree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;preorder&#39;</span><span class="p">):</span>
    <span class="n">traversal</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;preorder&quot;</span><span class="p">:</span>
        <span class="k">pass</span>
</pre></div>
</div>
</div>
</div>
<section id="build">
<h2>Build<a class="headerlink" href="#build" title="Permalink to this heading">#</a></h2>
<section id="from-preorder">
<h3>From Preorder<a class="headerlink" href="#from-preorder" title="Permalink to this heading">#</a></h3>
<p>How to build a BST from given preorder traversal? For example if the given preorder traversal is [10,5,1,7,40,50], then the BST has the following format:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        10
        / \
       5   40
      / \    \
     1   7   50
</pre></div>
</div>
<p><strong>Important</strong></p>
<ul class="simple">
<li><p>In <code class="docutils literal notranslate"><span class="pre">preorder</span></code> traversal, the root node always comes first.</p></li>
<li><p>The key is to find its left subtree and right subtree from a given root using the above principle.</p></li>
<li><p>Together with <code class="docutils literal notranslate"><span class="pre">inorder</span></code>, where left subtree always comes first, it is easy to reconstruct a general binary tree.</p></li>
</ul>
<p><strong>Notes</strong></p>
<ul class="simple">
<li><p>General BT construction needs both preorder and inorder traversals, but BST can be constructed from preorder traversal only or postorder traversal only.</p></li>
<li><p>BST cannot be constructed from inorder traveral only.</p></li>
</ul>
<p><strong>Leetcode</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/">1008</a></p></li>
</ul>
<section id="method-1">
<h4>Method 1<a class="headerlink" href="#method-1" title="Permalink to this heading">#</a></h4>
<ul class="simple">
<li><p>The first element of the preorder traversal <code class="docutils literal notranslate"><span class="pre">A</span></code> is always root.</p></li>
<li><p>Then we find the first element that is greater than the root, and get its index <code class="docutils literal notranslate"><span class="pre">i</span></code>. In 0-index language, any values between <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">i</span></code> shall be the left subtree, and values between <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">-1</span></code> shall be the right subtree.</p></li>
<li><p>Recursively cconstruct the left subtree using <code class="docutils literal notranslate"><span class="pre">A[1:i]</span></code> and right subtree using <code class="docutils literal notranslate"><span class="pre">A[i:]</span></code>.</p></li>
</ul>
<p><strong>Complexity</strong></p>
<ul class="simple">
<li><p>time: <span class="math notranslate nohighlight">\(O(n^2)\)</span></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_preorder</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="c1"># return None if empty</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">A</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># get root</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">val</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="c1"># get left subtree and right subtree</span>
    <span class="c1"># using the first element of the right subtree</span>
    <span class="c1"># or we can use inorder traversal here by sorting the preorder traversal</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="c1"># recurse</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">build_preorder</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">build_preorder</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
    
    <span class="c1"># combine </span>
    <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span> 
    <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span> 

    <span class="k">return</span> <span class="n">root</span>
    
<span class="c1"># test</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">build_preorder</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">build_preorder</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">build_preorder</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[10, 5, 1, 7, 40, 50]
[]
[1]
</pre></div>
</div>
</div>
</div>
</section>
<section id="method-2">
<h4>Method 2<a class="headerlink" href="#method-2" title="Permalink to this heading">#</a></h4>
<p>Traverse each element in the preorder traversal, and compare its value with the root value</p>
<ul class="simple">
<li><p>if the node value is less than the root value, change root to its left</p></li>
<li><p>if the node value is greater than the root value, change root to its right</p></li>
<li><p>recurse until the node is inserted correctly</p></li>
</ul>
<p><strong>Complexity</strong></p>
<ul class="simple">
<li><p>time: <span class="math notranslate nohighlight">\(O(n^2)\)</span></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">buildBST</span><span class="p">(</span><span class="n">preorder</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">A</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span> 
    
    <span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">preorder</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">root</span>
    
    <span class="c1"># insert</span>
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="c1"># base case</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span>
        
        <span class="c1"># insert to left tree or right tree</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">root</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    
    <span class="k">return</span> <span class="n">root</span>

<span class="c1"># test</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[10, 5, 1, 7, 40, 50]
[]
[1]
</pre></div>
</div>
</div>
</div>
</section>
<section id="method-3">
<h4>Method 3<a class="headerlink" href="#method-3" title="Permalink to this heading">#</a></h4>
<p>The information of the binary tree can be saved using preorder traversal and inorder traversal.</p>
<p>The key idea here is:</p>
<ul class="simple">
<li><p>preorder traversal preserves the node order in [root, left, right]</p></li>
<li><p>inorder traversal preserves the node order in [left, root, right]. For BST, the inorder traversal is sorted increasingly.</p>
<ul>
<li><p>we can get the inroder traversal of BST easily from sorting the preorder traversal.</p></li>
<li><p>The first element in the preorder traversal is always the root, and the left slice of the inorder traversal to the root is the whole left subtree.</p></li>
<li><p>Therefore, we just need to know the index of the root in the inorder traversal.</p></li>
</ul>
</li>
</ul>
<p><strong>Complexity</strong></p>
<ul class="simple">
<li><p>time: <span class="math notranslate nohighlight">\(O(n^2log(n))\)</span></p></li>
<li><p>space: <span class="math notranslate nohighlight">\(O(n)\)</span>. Extra space for storing inorder traversal and recursive call stack, whose worst scenario is <span class="math notranslate nohighlight">\(O(n)\)</span> when the tree is left-skewed.</p></li>
</ul>
<p><strong>This could be improved to <span class="math notranslate nohighlight">\(O(n)\)</span> time</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">buildBST</span><span class="p">(</span><span class="n">preorder</span><span class="p">):</span>
    <span class="c1"># base case</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">preorder</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    
    <span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># get inorder traversal of a BST</span>
    <span class="n">inorder</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">preorder</span><span class="p">)</span>

    <span class="c1"># find root index in inorder traversal</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">inorder</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="c1"># build left</span>
    <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">root</span>

<span class="c1"># test</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[10, 5, 1, 7, 40, 50]
[10, 5, 3, 1, 4, 7, 6, 8, 40, 50]
</pre></div>
</div>
</div>
</div>
</section>
<section id="method-4">
<h4>Method 4<a class="headerlink" href="#method-4" title="Permalink to this heading">#</a></h4>
<p>See https://www.youtube.com/watch?v=UmJT3j26t1I.</p>
<p>BST node has a property that determines the range of its subtree.
The key idea here is use the upper bounds of each explored node to decide where a specific node should be inserted:</p>
<ul class="simple">
<li><p>initialize the upper bound of the root as <code class="docutils literal notranslate"><span class="pre">INF</span></code></p></li>
<li><p>for each node, recursively</p>
<ul>
<li><p>build the left subtree using upper bound <code class="docutils literal notranslate"><span class="pre">node.val</span></code></p></li>
<li><p>build the right subtree using upper bound the current node’s parent upper bound</p></li>
</ul>
</li>
</ul>
<p><strong>Complexity</strong></p>
<ul class="simple">
<li><p>time: O(n). For each node, we at most visit 3 times, thus the worst scenario is <span class="math notranslate nohighlight">\(O(3n)\)</span>, which is <span class="math notranslate nohighlight">\(O(n)\)</span></p></li>
<li><p>space: O(n). This recursive algorithm uses stack space.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># The recursion is so beatiful here. Try to understand</span>
<span class="c1"># The key point here is: </span>
<span class="c1"># 1. A is globally changed by each recursion.</span>
<span class="c1"># 2. The recusion always build left brach first. Until no left node is possible, it will build the right branch from the bottom of left subtree to the right subtree of the root.</span>
<span class="k">def</span> <span class="nf">buildBST</span><span class="p">(</span><span class="n">preorder</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">A</span> <span class="ow">or</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ub</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>
        <span class="c1">#print(A)</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;A for left: </span><span class="si">{</span><span class="n">A</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;A for right: </span><span class="si">{</span><span class="n">A</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">root</span>

    <span class="k">return</span> <span class="n">build</span><span class="p">(</span><span class="n">preorder</span><span class="p">)</span> 

<span class="c1"># test</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

<span class="c1">#A = []</span>
<span class="c1">#root = buildBST(A)</span>
<span class="c1">#print(traverse_preorder(root))</span>

<span class="c1">#A = [1]</span>
<span class="c1">#root = buildBST(A)</span>
<span class="c1">#print(traverse_preorder(root))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>A for left: [5, 1, 7, 40, 50]
A for left: [1, 7, 40, 50]
A for left: [7, 40, 50]
A for right: [7, 40, 50]
A for right: [7, 40, 50]
A for left: [40, 50]
A for right: [40, 50]
A for right: [40, 50]
A for left: [50]
A for right: [50]
A for left: []
A for right: []
[10, 5, 1, 7, 40, 50]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># A wrong implementation:</span>
<span class="c1"># the index i is not global, which results the same node will be attached to both left and right if possible.</span>
<span class="k">def</span> <span class="nf">buildBST</span><span class="p">(</span><span class="n">preorder</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="ow">or</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ub</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">root</span>

    <span class="k">return</span> <span class="n">build</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> 

<span class="c1"># The following implementation fixes the above code</span>
<span class="k">def</span> <span class="nf">buildBST</span><span class="p">(</span><span class="n">preorder</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">i</span> 
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)):</span>
        <span class="k">global</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="ow">or</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ub</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">root</span>

    <span class="k">return</span> <span class="n">build</span><span class="p">(</span><span class="n">preorder</span><span class="p">)</span> 

<span class="c1"># test</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[10, 5, 1, 7, 40, 50]
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="build-all-bst-from-inorder-traversal">
<h3>Build All BST from Inorder Traversal<a class="headerlink" href="#build-all-bst-from-inorder-traversal" title="Permalink to this heading">#</a></h3>
<p>Inorder traversal alone cannot define a unique BST. But based on inorder traversal, we can get all the possible BST structures. How?</p>
<p>See <a class="reference external" href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-b16de/">here</a>.</p>
<p>This will require dynamic programming. We will come back later.</p>
</section>
</section>
<section id="traverse">
<h2>Traverse<a class="headerlink" href="#traverse" title="Permalink to this heading">#</a></h2>
<p>Traverse the BST node by node.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Depth-first</span> <span class="pre">Search</span></code></p>
<ul>
<li><p>preorder</p></li>
<li><p>inorder</p></li>
<li><p>postorder</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Breadth-first</span> <span class="pre">Search</span></code></p>
<ul>
<li><p>level-order</p></li>
</ul>
</li>
</ul>
<section id="preorder-traversal">
<h3>Preorder Traversal<a class="headerlink" href="#preorder-traversal" title="Permalink to this heading">#</a></h3>
<p>Preorder traversal is used to create a copy of the tree. Preorder traversal is also used to get prefix expressions on an expression tree.</p>
<ul class="simple">
<li><p>visit the root</p></li>
<li><p>traverse the left subtree</p></li>
<li><p>traverse the right subtree</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Method 1: dynamic programming: divide into subproblem and integrate subproblem solutions to get final solution</span>
<span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="c1"># base case</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># store node </span>
    <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">]</span>
    <span class="c1"># traverse the left subtree and right subtree</span>
    <span class="n">order</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">))</span>
    <span class="n">order</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">))</span>
    
    <span class="c1"># return</span>
    <span class="k">return</span> <span class="n">order</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[10, 5, 1, 7, 40, 50]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Method 2: backtracking </span>
<span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>

    <span class="c1"># traverse function</span>
    <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> 

        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[10, 5, 1, 7, 40, 50]
</pre></div>
</div>
</div>
</div>
</section>
<section id="inorder">
<h3>Inorder<a class="headerlink" href="#inorder" title="Permalink to this heading">#</a></h3>
<p>In the case of BST, Inorder traversal gives nodes in non-decreasing order. To get nodes of BST in non-increasing order, a variation of Inorder traversal where Inorder traversal is reversed can be used.</p>
<ul class="simple">
<li><p>traverse the left subtree</p></li>
<li><p>visit the root</p></li>
<li><p>traverse the rigth subtree</p></li>
</ul>
<p><strong>Recursive Implementation</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## A recursive implementation</span>
<span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="c1"># base case</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># traverse left subtree</span>
    <span class="n">order</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">))</span>
    <span class="n">order</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">])</span>
    <span class="n">order</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">order</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 5, 7, 10, 40, 50]
</pre></div>
</div>
</div>
</div>
<p><strong>Iterative Implementation Using Stack</strong></p>
<ol class="arabic">
<li><p>Create an empty stack S.</p></li>
<li><p>Initialize current node as root</p></li>
<li><p>Push the current node to S and set <code class="docutils literal notranslate"><span class="pre">current</span> <span class="pre">=</span> <span class="pre">current.left</span></code> until current is NULL</p></li>
<li><p>If current is NULL and stack is not empty then</p>
<ul class="simple">
<li><p>Pop the top item from stack.</p></li>
<li><p>Print the popped item, set <code class="docutils literal notranslate"><span class="pre">current</span> <span class="pre">=</span> <span class="pre">popped_item.right</span></code></p></li>
<li><p>Go to step 3.</p></li>
</ul>
</li>
<li><p>If current is NULL and stack is empty then we are done</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">============================================================</span>
Let<span class="w"> </span>us<span class="w"> </span>consider<span class="w"> </span>the<span class="w"> </span>below<span class="w"> </span>tree<span class="w"> </span><span class="k">for</span><span class="w"> </span>example<span class="w">  </span>


<span class="w">            </span><span class="m">1</span>
<span class="w">          </span>/<span class="w">   </span><span class="se">\</span>
<span class="w">        </span><span class="m">2</span><span class="w">      </span><span class="m">3</span>
<span class="w">       </span>/<span class="w">  </span><span class="se">\</span>
<span class="w">     </span><span class="m">4</span><span class="w">     </span><span class="m">5</span>

Step<span class="w"> </span><span class="m">1</span><span class="w"> </span>Creates<span class="w"> </span>an<span class="w"> </span>empty<span class="w"> </span>stack:<span class="w"> </span><span class="nv">S</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>NULL

Step<span class="w"> </span><span class="m">2</span><span class="w"> </span>sets<span class="w"> </span>current<span class="w"> </span>as<span class="w"> </span>address<span class="w"> </span>of<span class="w"> </span>root:<span class="w"> </span>current<span class="w"> </span>-&gt;<span class="w"> </span><span class="m">1</span>

Step<span class="w"> </span><span class="m">3</span><span class="w"> </span>Pushes<span class="w"> </span>the<span class="w"> </span>current<span class="w"> </span>node<span class="w"> </span>and<span class="w"> </span><span class="nb">set</span><span class="w"> </span><span class="nv">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>current-&gt;left<span class="w"> </span>
<span class="w">     </span><span class="k">until</span><span class="w"> </span>current<span class="w"> </span>is<span class="w"> </span>NULL
<span class="w">     </span>current<span class="w"> </span>-&gt;<span class="w"> </span><span class="m">1</span>
<span class="w">     </span>push<span class="w"> </span><span class="m">1</span>:<span class="w"> </span>Stack<span class="w"> </span>S<span class="w"> </span>-&gt;<span class="w"> </span><span class="m">1</span>
<span class="w">     </span>current<span class="w"> </span>-&gt;<span class="w"> </span><span class="m">2</span>
<span class="w">     </span>push<span class="w"> </span><span class="m">2</span>:<span class="w"> </span>Stack<span class="w"> </span>S<span class="w"> </span>-&gt;<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">1</span>
<span class="w">     </span>current<span class="w"> </span>-&gt;<span class="w"> </span><span class="m">4</span>
<span class="w">     </span>push<span class="w"> </span><span class="m">4</span>:<span class="w"> </span>Stack<span class="w"> </span>S<span class="w"> </span>-&gt;<span class="w"> </span><span class="m">4</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">1</span>
<span class="w">     </span><span class="nv">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>NULL

Step<span class="w"> </span><span class="m">4</span><span class="w"> </span>pops<span class="w"> </span>from<span class="w"> </span>S
<span class="w">     </span>a<span class="o">)</span><span class="w"> </span>Pop<span class="w"> </span><span class="m">4</span>:<span class="w"> </span>Stack<span class="w"> </span>S<span class="w"> </span>-&gt;<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">1</span>
<span class="w">     </span>b<span class="o">)</span><span class="w"> </span>print<span class="w"> </span><span class="s2">&quot;4&quot;</span>
<span class="w">     </span>c<span class="o">)</span><span class="w"> </span><span class="nv">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>NULL<span class="w"> </span>/*right<span class="w"> </span>of<span class="w"> </span><span class="m">4</span><span class="w"> </span>*/<span class="w"> </span>and<span class="w"> </span>go<span class="w"> </span>to<span class="w"> </span>step<span class="w"> </span><span class="m">3</span>
Since<span class="w"> </span>current<span class="w"> </span>is<span class="w"> </span>NULL<span class="w"> </span>step<span class="w"> </span><span class="m">3</span><span class="w"> </span>doesn<span class="s1">&#39;t do anything. </span>

<span class="s1">Step 4 pops again.</span>
<span class="s1">     a) Pop 2: Stack S -&gt; 1</span>
<span class="s1">     b) print &quot;2&quot;</span>
<span class="s1">     c) current -&gt; 5/*right of 2 */ and go to step 3</span>

<span class="s1">Step 3 pushes 5 to stack and makes current NULL</span>
<span class="s1">     Stack S -&gt; 5, 1</span>
<span class="s1">     current = NULL</span>

<span class="s1">Step 4 pops from S</span>
<span class="s1">     a) Pop 5: Stack S -&gt; 1</span>
<span class="s1">     b) print &quot;5&quot;</span>
<span class="s1">     c) current = NULL /*right of 5 */ and go to step 3</span>
<span class="s1">Since current is NULL step 3 doesn&#39;</span>t<span class="w"> </span><span class="k">do</span><span class="w"> </span>anything

Step<span class="w"> </span><span class="m">4</span><span class="w"> </span>pops<span class="w"> </span>again.
<span class="w">     </span>a<span class="o">)</span><span class="w"> </span>Pop<span class="w"> </span><span class="m">1</span>:<span class="w"> </span>Stack<span class="w"> </span>S<span class="w"> </span>-&gt;<span class="w"> </span>NULL
<span class="w">     </span>b<span class="o">)</span><span class="w"> </span>print<span class="w"> </span><span class="s2">&quot;1&quot;</span>
<span class="w">     </span>c<span class="o">)</span><span class="w"> </span>current<span class="w"> </span>-&gt;<span class="w"> </span><span class="m">3</span><span class="w"> </span>/*right<span class="w"> </span>of<span class="w"> </span><span class="m">1</span><span class="w"> </span>*/<span class="w">  </span>

Step<span class="w"> </span><span class="m">3</span><span class="w"> </span>pushes<span class="w"> </span><span class="m">3</span><span class="w"> </span>to<span class="w"> </span>stack<span class="w"> </span>and<span class="w"> </span>makes<span class="w"> </span>current<span class="w"> </span>NULL
<span class="w">     </span>Stack<span class="w"> </span>S<span class="w"> </span>-&gt;<span class="w"> </span><span class="m">3</span>
<span class="w">     </span><span class="nv">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>NULL

Step<span class="w"> </span><span class="m">4</span><span class="w"> </span>pops<span class="w"> </span>from<span class="w"> </span>S
<span class="w">     </span>a<span class="o">)</span><span class="w"> </span>Pop<span class="w"> </span><span class="m">3</span>:<span class="w"> </span>Stack<span class="w"> </span>S<span class="w"> </span>-&gt;<span class="w"> </span>NULL
<span class="w">     </span>b<span class="o">)</span><span class="w"> </span>print<span class="w"> </span><span class="s2">&quot;3&quot;</span>
<span class="w">     </span>c<span class="o">)</span><span class="w"> </span><span class="nv">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>NULL<span class="w"> </span>/*right<span class="w"> </span>of<span class="w"> </span><span class="m">3</span><span class="w"> </span>*/<span class="w">  </span>

Traversal<span class="w"> </span>is<span class="w"> </span><span class="k">done</span><span class="w"> </span>now<span class="w"> </span>as<span class="w"> </span>stack<span class="w"> </span>S<span class="w"> </span>is<span class="w"> </span>empty<span class="w"> </span>and<span class="w"> </span>current<span class="w"> </span>is<span class="w"> </span>NULL.
</pre></div>
</div>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## A iterative implementation: use a stack to store </span>
<span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="c1"># if use stack=[root]</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">root</span>
    <span class="c1"># Note len([None]=1)</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="c1"># pop if current is none and stack is not empty</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">curr</span><span class="p">:</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="c1"># get the order</span>
            <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="c1"># update current node</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">right</span>
        
        <span class="c1"># push all left nodes and then right node</span>
        <span class="k">while</span> <span class="n">curr</span><span class="p">:</span>
            <span class="c1"># avoid storing root twice</span>
            <span class="k">if</span> <span class="n">curr</span><span class="o">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">left</span>

    <span class="k">return</span> <span class="n">order</span>

<span class="c1"># Test</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">40</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 5, 7, 10, 40]
</pre></div>
</div>
</div>
</div>
<p><strong>Iterative Implementation without Stack</strong></p>
<p>This method is known as Morris Traversal.
See <a class="reference external" href="https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/?ref=lbp">here</a>.</p>
</section>
<section id="postorder">
<h3>Postorder<a class="headerlink" href="#postorder" title="Permalink to this heading">#</a></h3>
<p>Postorder traversal is used to delete the tree. Please see the question for the deletion of a tree for details. Postorder traversal is also useful to get the postfix expression of an expression tree</p>
<ul class="simple">
<li><p>traverse the left subtree</p></li>
<li><p>traverse the right subtree</p></li>
<li><p>visit the root</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">postorder</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="c1"># base </span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># traverse </span>
    <span class="n">order</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">postorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">))</span>
    <span class="n">order</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">postorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">))</span>
    <span class="n">order</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">])</span>

    <span class="c1"># return</span>
    <span class="k">return</span> <span class="n">order</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">postorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 5, 7, 10, 40, 50]
[1, 7, 5, 50, 40, 10]
</pre></div>
</div>
</div>
</div>
</section>
<section id="level-order-traversal">
<h3>Level Order Traversal<a class="headerlink" href="#level-order-traversal" title="Permalink to this heading">#</a></h3>
<p>Traverse the tree level by level from top to bottom</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">levelOrderTop</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="c1"># initialize</span>
    <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">root</span><span class="p">,</span> <span class="n">level</span><span class="p">)]</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">level_res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">level</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># traverse each level</span>
        <span class="k">while</span> <span class="n">queue</span> <span class="ow">and</span> <span class="n">level</span> <span class="o">==</span> <span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># pop all nodes from the same level</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># stack level result</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">level_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">level_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;null&#39;</span><span class="p">)</span>
            
            <span class="c1"># update queue: node at least has one child</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">and</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">):</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>

        <span class="c1"># stack level results to head:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">level_res</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">res</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">levelOrderTop</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 5, 7, 10, 40, 50]
[[10], [5, 40], [1, 7, &#39;null&#39;, 50]]
</pre></div>
</div>
</div>
</div>
<p>Traverse the tree level by level from bottom to top</p>
<p><em>Method 1:</em></p>
<ul class="simple">
<li><p>use a stack to store all nodes and level info level-by-level from top to bottom</p></li>
<li><p>pop the stack to another stack so that all the nodes in the same level are in the new stack</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">levelOrderBottom</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">root</span><span class="p">,</span> <span class="n">level</span><span class="p">)]</span>

    <span class="c1"># initialize two stacks</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># initialize output</span>
    <span class="n">res</span><span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># traverse to store all nodes in stack</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># save to a stack</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">level</span><span class="p">))</span>

        <span class="c1"># append children to queue: keep null as a place holder</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">and</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">):</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>

    <span class="c1"># pop stack to get level order traversal from bottom</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">level_stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># traverse level</span>
        <span class="n">level</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">level</span> <span class="o">==</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">level_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
        <span class="c1"># pop level_stack to get the output</span>
        <span class="n">level_res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">level_stack</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">level_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">level_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">level_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;null&#39;</span><span class="p">)</span>    
        <span class="c1"># output </span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">level_res</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">res</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">levelOrderBottom</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[1, 7, &#39;null&#39;, 50], [5, 40], [10]]
</pre></div>
</div>
</div>
</div>
<p><em>Method 2:</em></p>
<p>This method is the same as level traversal from top to down, but when appending level results, we insert the level result at the head instead of tail.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">levelOrderBottom</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="c1"># initialize</span>
    <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">root</span><span class="p">,</span> <span class="n">level</span><span class="p">)]</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">level_res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">level</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># traverse each level</span>
        <span class="k">while</span> <span class="n">queue</span> <span class="ow">and</span> <span class="n">level</span> <span class="o">==</span> <span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># pop all nodes from the same level</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># stack level result</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">level_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">level_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;null&#39;</span><span class="p">)</span>
            
            <span class="c1"># update queue: node at least has one child</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">and</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">):</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>

        <span class="c1"># stack level results to head:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">level_res</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">res</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">levelOrderBottom</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[1, 7, &#39;null&#39;, 50], [5, 40], [10]]
</pre></div>
</div>
</div>
</div>
</section>
<section id="serialization-and-deserialization">
<h3>Serialization and Deserialization<a class="headerlink" href="#serialization-and-deserialization" title="Permalink to this heading">#</a></h3>
</section>
</section>
<section id="serialization-is-a-way-to-convert-a-binary-tree-to-a-standard-format-which-then-can-be-used-by-external-tools">
<h2>Serialization is a way to convert a binary tree to a standard format, which then can be used by external tools.<a class="headerlink" href="#serialization-is-a-way-to-convert-a-binary-tree-to-a-standard-format-which-then-can-be-used-by-external-tools" title="Permalink to this heading">#</a></h2>
<p>Deserialization is a way to construct a binary tree from a given serialization format.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;level-order&quot;</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="nf">level_order_serialize</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        
        <span class="c1"># traverse level by level from top to down, and use null as a placeholder for missing child or children</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="k">if</span> <span class="n">node</span> <span class="k">else</span> <span class="s2">&quot;null&quot;</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="c1"># update queue</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">and</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">):</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;level-order&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">level_order_serialize</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;level-order&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[10, 5, 40, 1, 7, &#39;null&#39;, 50]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">serialization</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;level-order&#39;</span><span class="p">):</span>
    <span class="c1"># serialization represent a binary tree in its complete format by introducing null whereever possible.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">serialization</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    
    <span class="k">def</span> <span class="nf">level_order_deserialize</span><span class="p">(</span><span class="n">serialization</span><span class="p">):</span>
        <span class="k">pass</span>
       
</pre></div>
</div>
</div>
</div>
</section>
<section id="insertion">
<h2>Insertion<a class="headerlink" href="#insertion" title="Permalink to this heading">#</a></h2>
<p>A new key is always inserted at the leaf. We start searching for a key from the root until we hit a leaf node. Once a leaf node is found, the new node is added as a child of the leaf node.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>        Insert 3 to the following BST will lead to:

             10                                              10
            /  \                     insert 3               /  \
           5   40                    -------&gt;              5   40              
          / \    \                                        / \    \
         1  7    50                                      1   7   50
                                                          \
                                                           3
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># A recursion Implementation</span>
<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="c1"># base case</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span>
    
    <span class="c1"># insert recursively assuming no duplicates</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">:</span>
        <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">root</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>    
<span class="nb">print</span><span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 3, 5, 7, 10, 40, 50]
[10, 5, 1, 3, 7, 40, 50]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># An iterative implementation</span>
<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span> 
    <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span> 

    <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">cur</span>
        <span class="c1"># go left</span>
        <span class="k">if</span> <span class="n">cur</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">:</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">left</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># go right</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">right</span>
    
    <span class="c1"># specify connections</span>
    <span class="k">if</span> <span class="n">prev</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">:</span>
        <span class="n">prev</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">node</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="n">prev</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span>
    
    <span class="k">return</span> <span class="n">root</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>    
<span class="nb">print</span><span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 3, 5, 7, 10, 40, 50]
[10, 5, 1, 3, 7, 40, 50]
</pre></div>
</div>
</div>
</div>
</section>
<section id="deletion">
<h2>Deletion<a class="headerlink" href="#deletion" title="Permalink to this heading">#</a></h2>
<p>When we delete a node, three possibilities arise.</p>
<ol class="arabic simple">
<li><p>Node to be deleted is the leaf: Simply remove from the tree.</p></li>
</ol>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>              50                            50
           /     \         delete(20)      /   \
          30      70       ---------&gt;    30     70 
         /  \    /  \                     \    /  \ 
       20   40  60   80                   40  60   80
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Node to be deleted has only one child: Copy the child to the node and delete the child</p></li>
</ol>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>              50                            50
           /     \         delete(30)      /   \
          30      70       ---------&gt;    40     70 
            \    /  \                          /  \ 
            40  60   80                       60   80
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>Node to be deleted has two children: Find <code class="docutils literal notranslate"><span class="pre">inorder</span> <span class="pre">successor</span></code> of the node. Copy contents of the inorder successor to the node and delete the inorder successor. Note that <code class="docutils literal notranslate"><span class="pre">inorder</span> <span class="pre">predecessor</span></code> can also be used.</p></li>
</ol>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>              50                            60
           /     \         delete(50)      /   \
          40      70       ---------&gt;    40    70 
                 /  \                            \ 
                60   80                           80
</pre></div>
</div>
<p>The important thing to note is, inorder successor is needed only when the right child is not empty. In this particular case, inorder successor can be obtained by finding the minimum value in the right child of the node.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">successor</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;find the inorder successor for a given node</span>
<span class="sd">            - if root has no right child, return None</span>
<span class="sd">            - else return the leftmost node in the right subtree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span> 
        
        <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span>
        <span class="k">while</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span>

        <span class="k">return</span> <span class="n">node</span>

    <span class="c1"># base case</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">root</span> 
    
    <span class="c1"># if key is smaller than the root&#39;s key then it lies in the left subtree</span>
    <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
        <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="c1"># key is the same as the root key</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># root is a leaf</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># root has only one child - left </span>
        <span class="k">elif</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
            <span class="n">root</span> <span class="o">=</span> <span class="kc">None</span> 
            <span class="k">return</span> <span class="n">temp</span>
        <span class="c1"># root has only one child - right</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span>
            <span class="n">root</span> <span class="o">=</span> <span class="kc">None</span> 
            <span class="k">return</span> <span class="n">temp</span> 
        
        <span class="c1"># root has two children</span>
        <span class="n">succ</span> <span class="o">=</span> <span class="n">successor</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

        <span class="c1"># copy the content</span>
        <span class="c1">#right = root.right # need reverse the right subtree before deletion</span>
        <span class="c1">#left = root.left</span>
        <span class="n">root</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">succ</span><span class="o">.</span><span class="n">val</span>

        <span class="c1"># delete the inorder successor</span>
        <span class="c1">#root.left = left</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">succ</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">root</span>

<span class="c1"># test</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">70</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="mi">80</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  
<span class="n">root</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">70</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="mi">80</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  
<span class="n">root</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">70</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="mi">80</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  
<span class="n">root</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[50, 30, 40, 70, 60, 80]
[50, 40, 70, 60, 80]
[60, 40, 70, 80]
</pre></div>
</div>
</div>
</div>
</section>
<section id="search">
<h2>Search<a class="headerlink" href="#search" title="Permalink to this heading">#</a></h2>
<p>Search in binary tree is very simple which is the same as binary search.</p>
<section id="search-an-element">
<h3>Search an element<a class="headerlink" href="#search-an-element" title="Permalink to this heading">#</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ITERATIVE_TREE_SEARCH</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
        <span class="k">else</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span>
        <span class="k">return</span> <span class="n">root</span>
</pre></div>
</div>
</section>
<section id="minimum-and-maximum">
<h3>Minimum and Maximum<a class="headerlink" href="#minimum-and-maximum" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Minimum</span></code>: go to leftmost leaf node</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Maximum</span></code>: go to rightmost leaf node</p></li>
</ul>
</section>
<section id="successor-and-predecessor">
<h3>Successor and Predecessor<a class="headerlink" href="#successor-and-predecessor" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Successor</span></code>: inorder sucessor is the next element in the inorder traversal order.</p>
<ul>
<li><p>If current node has right subtree, then return left most leaf of the right-subtree (for BST, which is the minimum node of the right subtree)</p></li>
<li><p>If current node has no right subtree, then return the lowest ancestor</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="applications">
<h2>Applications<a class="headerlink" href="#applications" title="Permalink to this heading">#</a></h2>
<section id="binary-tree-to-bst">
<h3>Binary Tree to BST<a class="headerlink" href="#binary-tree-to-bst" title="Permalink to this heading">#</a></h3>
<p>Given a Binary Tree, convert it to a Binary Search Tree. The conversion must be done in such a way that keeps the original structure of Binary Tree.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="mi">1</span>
<span class="n">Input</span><span class="p">:</span>
          <span class="mi">10</span>
         <span class="o">/</span>  \
        <span class="mi">2</span>    <span class="mi">7</span>
       <span class="o">/</span> \
      <span class="mi">8</span>   <span class="mi">4</span>
<span class="n">Output</span><span class="p">:</span>
          <span class="mi">8</span>
         <span class="o">/</span>  \
        <span class="mi">4</span>    <span class="mi">10</span>
       <span class="o">/</span> \
      <span class="mi">2</span>   <span class="mi">7</span>


<span class="n">Example</span> <span class="mi">2</span>
<span class="n">Input</span><span class="p">:</span>
          <span class="mi">10</span>
         <span class="o">/</span>  \
        <span class="mi">30</span>   <span class="mi">15</span>
       <span class="o">/</span>      \
      <span class="mi">20</span>       <span class="mi">5</span>
<span class="n">Output</span><span class="p">:</span>
          <span class="mi">15</span>
         <span class="o">/</span>  \
       <span class="mi">10</span>    <span class="mi">20</span>
       <span class="o">/</span>      \
      <span class="mi">5</span>        <span class="mi">30</span>
</pre></div>
</div>
</section>
<section id="analysis">
<h3>Analysis<a class="headerlink" href="#analysis" title="Permalink to this heading">#</a></h3>
<p>three steps:</p>
<ul class="simple">
<li><p>get inorder traveral as an array from binary tree</p></li>
<li><p>sort the array for BST</p></li>
<li><p>inorder traverse the binary tree, and copy to the value of each node from the sorted array. We have to do inorder, because the sorted array is an inorder representation of BST.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">convertBTtoBST</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">traverse_inorder</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        
        <span class="n">l</span> <span class="o">=</span> <span class="n">traverse_inorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">traverse_inorder</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">l</span> <span class="o">+</span> <span class="n">v</span> <span class="o">+</span> <span class="n">r</span>
    
    <span class="k">def</span> <span class="nf">buildBST</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">arr_sort</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> 
        <span class="c1"># no preorder operation</span>

        <span class="c1"># traverse left subtree</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">arr_sort</span><span class="p">)</span>

        <span class="c1"># inorder operation - replace value</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">arr_sort</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">v</span>

        <span class="c1"># traverse right subtree</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">arr_sort</span><span class="p">)</span>
        <span class="c1"># no postorder operation</span>

        <span class="k">return</span> <span class="n">root</span>

    <span class="n">arr</span> <span class="o">=</span> <span class="n">traverse_inorder</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="n">arr_sort</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">buildBST</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">arr_sort</span><span class="p">)</span>

<span class="c1"># test</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
<span class="n">bst</span> <span class="o">=</span> <span class="n">convertBTtoBST</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">traverse_preorder</span><span class="p">(</span><span class="n">bst</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[10, 30, 20, 15, 5]
[15, 10, 5, 20, 30]
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="tree-map">
<h2>Tree Map<a class="headerlink" href="#tree-map" title="Permalink to this heading">#</a></h2>
<p>See Leetcode 1038 and 538.</p>
<p>The problem is to map a BST to a greater tree or a geater sum tree.</p>
<p>For a greater tree, convert a BST to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.</p>
<section id="id1">
<h3>Analysis<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>inorder traversal of a BST is a sequence with increasingly sorted keys. One naive apporach is:</p>
<ul>
<li><p>get inorder traversal of BST</p></li>
<li><p>get greater sum of the inorder sequences</p></li>
<li><p>build binary tree with the greater sum sequence but follow the original BST structure</p></li>
<li><p>this method is O(n) in both time and complexity</p></li>
</ul>
</li>
<li><p>How can we implement it using sub-problem method?</p>
<ul>
<li><p>maintain a sum that recursively add the current value to previous greater sum</p></li>
<li><p>inorder traverse the BST with decreasing keys (traverse right then left)</p></li>
<li><p>inorder change the node value with presum</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="valid-bst">
<h2>Valid BST<a class="headerlink" href="#valid-bst" title="Permalink to this heading">#</a></h2>
<p>It looks easy to check if a binary tree is a valid BST by simply comparing the keys in node, node.left, and node.right.</p>
<p>But there is a trap using this method. Look at the below tree, where the left subtree and right subtree are both valid BST, and the node value 5&lt;10&lt;15, but it is not a valid BST as a whole.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     10
    /  \
   5    15
       /  \
      6   20
</pre></div>
</div>
<p>The reason is the above method doesn’t guarantee that all values in the right subtree is greater than the node value, and all values in the left subtree should be smaller than the node value.</p>
<p>For binary tree, we know the upper and lower bound for each node. We can use this property to check if all nodes are within correct bounds.</p>
<p><strong>Pesudo code</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>boolean isValidBST(TreeNode root) {
    return isValidBST(root, null, null);
}

/* 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.val */
boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {
    // base case
    if (root == null) return true;
    // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST
    if (min != null &amp;&amp; root.val &lt;= min.val) return false;
    if (max != null &amp;&amp; root.val &gt;= max.val) return false;
    // 限定左子树的最大值是 root.val，右子树的最小值是 root.val
    return isValidBST(root.left, min, root) 
        &amp;&amp; isValidBST(root.right, root, max);
}
</pre></div>
</div>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="avl-tree">
<h1>AVL Tree<a class="headerlink" href="#avl-tree" title="Permalink to this heading">#</a></h1>
<p>AVL tree is a self-balancing Binary Search Tree (BST) where the difference between heights of left and right subtrees cannot be more than one for all nodes.</p>
<p>Most of the BST operations (e.g., search, max, min, insert, delete.. etc) take O(h) time where h is the height of the BST. The cost of these operations may become O(n) for a skewed Binary tree. If we make sure that the height of the tree remains O(log(n)) after every insertion and deletion, then we can guarantee an upper bound of O(log(n)) for all these operations. The height of an AVL tree is always O(log(n)) where n is the number of nodes in the tree.</p>
<section id="id2">
<h2>Insertion<a class="headerlink" href="#id2" title="Permalink to this heading">#</a></h2>
<p>To make sure that the given tree remains AVL after every insertion, we must augment the standard BST insert operation to perform some re-balancing without violating BST properties.
Two operations can be performed:</p>
<ul class="simple">
<li><p>left rotation</p></li>
<li><p>right rotation</p></li>
</ul>
<p>** Steps for Insertion **</p>
<p>Let the newly inserted node be <code class="docutils literal notranslate"><span class="pre">w</span></code></p>
<ul class="simple">
<li><p>Perform standard BST insert for <code class="docutils literal notranslate"><span class="pre">w</span></code>.</p></li>
<li><p>Starting from <code class="docutils literal notranslate"><span class="pre">w</span></code>, travel up and find the first unbalanced node. Let <code class="docutils literal notranslate"><span class="pre">z</span></code> be the first unbalanced node, <code class="docutils literal notranslate"><span class="pre">y</span></code> be the child of <code class="docutils literal notranslate"><span class="pre">z</span></code> that comes on the path from <code class="docutils literal notranslate"><span class="pre">w</span></code> to <code class="docutils literal notranslate"><span class="pre">z</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> be the grandchild of <code class="docutils literal notranslate"><span class="pre">z</span></code> that comes on the path from <code class="docutils literal notranslate"><span class="pre">w</span></code> to <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p></li>
<li><p>Re-balance the tree by performing appropriate rotations on the subtree rooted with <code class="docutils literal notranslate"><span class="pre">z</span></code>. There can be 4 possible cases that need to be handled as <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code> can be arranged in 4 ways.</p></li>
<li><p>Following are the possible 4 arrangements:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> is the left child of <code class="docutils literal notranslate"><span class="pre">z</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> is the left child of <code class="docutils literal notranslate"><span class="pre">y</span></code> (Left Left Case)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> is the left child of <code class="docutils literal notranslate"><span class="pre">z</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> is the right child of <code class="docutils literal notranslate"><span class="pre">y</span></code> (Left Right Case)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> is the right child of <code class="docutils literal notranslate"><span class="pre">z</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> is the right child of <code class="docutils literal notranslate"><span class="pre">y</span></code> (Right Right Case)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> is the right child of <code class="docutils literal notranslate"><span class="pre">z</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> is the left child of <code class="docutils literal notranslate"><span class="pre">y</span></code> (Right Left Case)</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="red-black-tree">
<h1>Red-Black Tree<a class="headerlink" href="#red-black-tree" title="Permalink to this heading">#</a></h1>
<p>red-black tree is a binary search tree with one extra bit of storage per node: its color, which can be either red or black.</p>
<ol class="arabic simple">
<li><p>Every node is either red or black.</p></li>
<li><p>The root is black.</p></li>
<li><p>Every leaf is black.</p></li>
<li><p>If a node is red, then both its children are black.</p></li>
<li><p>For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.</p></li>
</ol>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./notes\data-structure"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="3-stack-and-queue.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Chapter 3. Stack</p>
      </div>
    </a>
    <a class="right-next"
       href="5-binary-tree.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Cahpter 5. Binary Tree</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Chapter 4. Binary Search Tree</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#build">Build</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-preorder">From Preorder</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#method-1">Method 1</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#method-2">Method 2</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#method-3">Method 3</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#method-4">Method 4</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#build-all-bst-from-inorder-traversal">Build All BST from Inorder Traversal</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#traverse">Traverse</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#preorder-traversal">Preorder Traversal</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#inorder">Inorder</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#postorder">Postorder</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#level-order-traversal">Level Order Traversal</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#serialization-and-deserialization">Serialization and Deserialization</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#serialization-is-a-way-to-convert-a-binary-tree-to-a-standard-format-which-then-can-be-used-by-external-tools">Serialization is a way to convert a binary tree to a standard format, which then can be used by external tools.</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#insertion">Insertion</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#deletion">Deletion</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#search">Search</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#search-an-element">Search an element</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#minimum-and-maximum">Minimum and Maximum</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#successor-and-predecessor">Successor and Predecessor</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#applications">Applications</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#binary-tree-to-bst">Binary Tree to BST</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#analysis">Analysis</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tree-map">Tree Map</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Analysis</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#valid-bst">Valid BST</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#avl-tree">AVL Tree</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">Insertion</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#red-black-tree">Red-Black Tree</a></li>
</ul>

  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Yangyang Fu
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=ac02cc09edc035673794"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>